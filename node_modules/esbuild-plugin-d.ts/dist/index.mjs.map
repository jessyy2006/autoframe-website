{"version":3,"sources":["../src/lib/getCompilerOptions.ts","../src/lib/resolveTSConfig.ts","../src/lib/humanizeFileSize.ts","../src/plugin.ts","../src/lib/generateBundle.ts","../src/lib/logger.ts"],"sourcesContent":["import { BuildOptions } from \"esbuild\";\nimport { createHash } from \"node:crypto\";\nimport { resolve } from \"node:path\";\nimport ts from \"typescript\";\n\nimport { DTSPluginOpts } from \"@/types\";\n\nexport function getCompilerOptions(opts: {\n    tsconfig: any;\n    pluginOptions: DTSPluginOpts;\n    esbuildOptions: BuildOptions;\n    willBundleDeclarations: boolean;\n}) {\n    const compilerOptions = ts.convertCompilerOptionsFromJson(\n        opts.tsconfig.compilerOptions,\n        process.cwd(),\n    ).options;\n\n    compilerOptions.declaration = true;\n    compilerOptions.emitDeclarationOnly = true;\n\n    if (!compilerOptions.declarationDir) {\n        compilerOptions.declarationDir =\n            compilerOptions.declarationDir ??\n            opts.esbuildOptions.outdir ??\n            compilerOptions.outDir;\n    }\n\n    if (opts.willBundleDeclarations) {\n        compilerOptions.declarationDir = resolve(\n            compilerOptions.declarationDir!,\n            \"dts-prebundle\",\n        );\n    }\n\n    if (compilerOptions.incremental && !compilerOptions.tsBuildInfoFile) {\n        const configHash = createHash(\"sha256\")\n            .update(\n                JSON.stringify({\n                    compilerOptions,\n                    __buildContext: opts.pluginOptions?.__buildContext,\n                }),\n            )\n            .digest(\"hex\");\n\n        const cacheDir = resolve(\n            require.resolve(\"esbuild/package.json\"),\n            \"../../.cache/esbuild-plugin-d.ts\",\n        );\n\n        compilerOptions.tsBuildInfoFile = resolve(\n            opts.pluginOptions.buildInfoDir ?? cacheDir,\n            `esbuild-plugin-dts-${configHash}.tsbuildinfo`,\n        );\n    }\n\n    compilerOptions.listEmittedFiles = true;\n\n    return compilerOptions;\n}\n","import merge from \"lodash.merge\";\nimport { readFileSync } from \"node:fs\";\nimport { dirname, resolve } from \"node:path\";\nimport ts from \"typescript\";\n\nfunction resolveModulePath(path: string) {\n    try {\n        return require.resolve(path);\n    } catch (e) {\n        return undefined;\n    }\n}\n\nexport function resolveTSConfig(opts: {\n    configPath?: string;\n    configName?: string;\n    searchPath?: string;\n}) {\n    let configPath =\n        opts.configPath ??\n        ts.findConfigFile(\n            opts.searchPath ?? process.cwd(),\n            ts.sys.fileExists,\n            opts.configName,\n        );\n    if (!configPath) {\n        throw new Error(\"No config file found\");\n    }\n\n    if (configPath.startsWith(\".\")) {\n        configPath = require.resolve(configPath);\n    }\n\n    const config = ts.readConfigFile(configPath, (path) =>\n        readFileSync(path, \"utf-8\"),\n    );\n\n    if (config.config.extends) {\n        const parentConfig = resolveTSConfig({\n            ...opts,\n            configPath:\n                resolveModulePath(config.config.extends) ??\n                resolve(dirname(configPath), config.config.extends),\n        }).config;\n\n        config.config = merge(parentConfig, config.config);\n    }\n\n    if (config.error) {\n        throw config.error;\n    } else {\n        return {\n            config: config.config,\n            configPath,\n        };\n    }\n}\n","export function humanizeFileSize(size: number): string {\n    const i = Math.floor(Math.log(size) / Math.log(1024));\n    return (\n        Math.round((size / Math.pow(1024, i)) * 100) / 100 +\n        [\"b\", \"kb\", \"mb\", \"gb\", \"tb\"][i]\n    );\n}\n","import chalk from \"chalk\";\nimport { PartialMessage, Plugin } from \"esbuild\";\nimport { existsSync, lstatSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\nimport ts from \"typescript\";\n\nimport { humanizeFileSize } from \"@/lib\";\nimport { generateBundle } from \"@/lib/generateBundle\";\nimport { getCompilerOptions } from \"@/lib/getCompilerOptions\";\nimport { createLogger } from \"@/lib/logger\";\nimport { resolveTSConfig } from \"@/lib/resolveTSConfig\";\nimport { DTSPluginOpts } from \"@/types/options\";\n\nexport const dtsPlugin = (opts: DTSPluginOpts = {}) =>\n    ({\n        name: \"dts-plugin\",\n        async setup(build) {\n            const log = createLogger(build.initialOptions.logLevel);\n\n            const { config, configPath } =\n                opts.tsconfig && typeof opts.tsconfig !== \"string\"\n                    ? { config: opts.tsconfig, configPath: undefined }\n                    : resolveTSConfig({\n                          configPath: opts.tsconfig,\n                      });\n\n            // TODO: uncomment once proven to work\n            // const willBundleDeclarations =\n            //     !!build.initialOptions.bundle &&\n            //     Array.isArray(build.initialOptions.entryPoints);\n            const willBundleDeclarations =\n                !!opts.experimentalBundling &&\n                Array.isArray(build.initialOptions.entryPoints);\n\n            const compilerOptions = getCompilerOptions({\n                tsconfig: config,\n                pluginOptions: opts,\n                esbuildOptions: build.initialOptions,\n                willBundleDeclarations,\n            });\n\n            const compilerHost = compilerOptions.incremental\n                ? ts.createIncrementalCompilerHost(compilerOptions)\n                : ts.createCompilerHost(compilerOptions);\n\n            const inputFiles: string[] = [];\n\n            build.onLoad({ filter: /(\\.tsx|\\.ts)$/ }, async (args) => {\n                inputFiles.push(args.path);\n\n                const errors: PartialMessage[] = [];\n\n                compilerHost.getSourceFile(\n                    args.path,\n                    compilerOptions.target ?? ts.ScriptTarget.Latest,\n                    (m) => {\n                        errors.push({\n                            detail: m,\n                        });\n                    },\n                    true,\n                );\n\n                return {\n                    errors,\n                };\n            });\n\n            build.onEnd(() => {\n                let compilerProgram;\n\n                if (compilerOptions.incremental) {\n                    compilerProgram = ts.createIncrementalProgram({\n                        options: compilerOptions,\n                        host: compilerHost,\n                        rootNames: inputFiles,\n                    });\n                } else {\n                    compilerProgram = ts.createProgram(\n                        inputFiles,\n                        compilerOptions,\n                        compilerHost,\n                    );\n                }\n\n                const diagnostics = ts\n                    .getPreEmitDiagnostics(compilerProgram as ts.Program)\n                    .map(\n                        (d) =>\n                            ({\n                                text:\n                                    typeof d.messageText === \"string\"\n                                        ? d.messageText\n                                        : d.messageText.messageText,\n                                detail: d,\n                                location: {\n                                    file: d.file?.fileName,\n                                    namespace: \"file\",\n                                },\n                                category: d.category,\n                            }) satisfies PartialMessage & {\n                                category: ts.DiagnosticCategory;\n                            },\n                    );\n\n                const errors = diagnostics\n                    .filter((d) => d.category === ts.DiagnosticCategory.Error)\n                    .map(({ category: _, ...message }) => message);\n\n                const warnings = diagnostics\n                    .filter((d) => d.category === ts.DiagnosticCategory.Warning)\n                    .map(({ category: _, ...message }) => message);\n\n                if (errors.length > 0) {\n                    return {\n                        errors,\n                        warnings,\n                    };\n                }\n\n                const startTime = Date.now();\n                const emitResult = compilerProgram.emit();\n\n                if (willBundleDeclarations) {\n                    let entryPoints: string[] = [];\n\n                    if (Array.isArray(build.initialOptions.entryPoints)) {\n                        entryPoints = build.initialOptions.entryPoints.map(\n                            (entry: string | { in: string }) =>\n                                typeof entry === \"string\" ? entry : entry.in,\n                        );\n                    } else {\n                        entryPoints = Object.values(\n                            build.initialOptions.entryPoints!,\n                        );\n                    }\n\n                    generateBundle(\n                        entryPoints,\n                        compilerOptions,\n                        configPath,\n                        config,\n                    );\n                }\n\n                if (\n                    emitResult.emitSkipped ||\n                    typeof emitResult.emittedFiles === \"undefined\"\n                ) {\n                    log.info(chalk`{yellow No declarations emitted}`);\n                } else {\n                    for (const emittedFile of emitResult.emittedFiles) {\n                        const emittedPath = resolve(emittedFile);\n\n                        if (\n                            existsSync(emittedPath) &&\n                            emittedPath !== compilerOptions.tsBuildInfoFile\n                        ) {\n                            const stat = lstatSync(emittedPath);\n\n                            const pathFromContentRoot = emittedPath\n                                .replace(resolve(process.cwd()), \"\")\n                                .replace(/^[\\\\/]/, \"\");\n                            const humanFileSize = humanizeFileSize(stat.size);\n\n                            log.info(\n                                chalk`  {bold ${pathFromContentRoot}} {cyan ${humanFileSize}}`,\n                            );\n                        }\n                    }\n                }\n\n                log.info(\n                    chalk`{green Finished compiling declarations in ${\n                        Date.now() - startTime\n                    }ms}`,\n                );\n\n                return {\n                    warnings,\n                };\n            });\n        },\n    }) as Plugin;\n","import { generateDtsBundle } from \"dts-bundle-generator\";\nimport { randomBytes } from \"node:crypto\";\nimport { rmSync, writeFileSync } from \"node:fs\";\nimport { dirname, sep as pathSeparator, resolve } from \"node:path\";\nimport ts from \"typescript\";\n\nfunction getHighestCommonDirectory(paths: string[]): string {\n    if (paths.length === 0) {\n        return \"\";\n    } else if (paths.length === 1) {\n        return dirname(paths[0]);\n    }\n\n    const [firstPath, ...otherPaths] = paths.map((p) => p.split(pathSeparator));\n    let commonParts = firstPath;\n\n    for (const currentPath of otherPaths) {\n        commonParts = commonParts.slice(\n            0,\n            commonParts.findIndex((part, i) => part !== currentPath[i]) ||\n                commonParts.length,\n        );\n    }\n\n    return commonParts.join(pathSeparator);\n}\n\nexport function generateBundle(\n    entryPoints: string[],\n    compilerOptions: ts.CompilerOptions,\n    tsconfigPath?: string,\n    originalConfig?: any,\n) {\n    const commonOutDir = getHighestCommonDirectory(entryPoints);\n\n    const relativeDeclarationPaths = entryPoints.map((entry) =>\n        entry.replace(commonOutDir + \"/\", \"\").replace(/\\.tsx?$/, \".d.ts\"),\n    );\n    const postbundleOutDir = resolve(compilerOptions.declarationDir!, \"..\");\n\n    let shouldDeleteTsConfig = false;\n    if (!tsconfigPath && originalConfig) {\n        const tempid = randomBytes(6).toString(\"hex\");\n\n        tsconfigPath = resolve(process.cwd(), `tsconfig.${tempid}.json`);\n\n        writeFileSync(\n            tsconfigPath,\n            JSON.stringify({\n                ...originalConfig,\n                compilerOptions: {\n                    ...originalConfig.compilerOptions,\n                    declaration: true,\n                    emitDeclarationOnly: true,\n                    declarationDir: postbundleOutDir,\n                },\n                include: entryPoints,\n            }),\n        );\n\n        shouldDeleteTsConfig = true;\n    }\n\n    try {\n        const bundles = generateDtsBundle(\n            relativeDeclarationPaths.map((path) => ({\n                filePath: resolve(compilerOptions.declarationDir!, path),\n            })),\n            {\n                preferredConfigPath: tsconfigPath,\n            },\n        );\n\n        for (let i = 0; i < bundles.length; i++) {\n            const bundle = bundles[i];\n            const originalPath = relativeDeclarationPaths[i];\n\n            const outputPath = resolve(postbundleOutDir, originalPath);\n\n            writeFileSync(outputPath, bundle);\n        }\n\n        if (compilerOptions.declarationDir!.endsWith(\"dts-prebundle\")) {\n            rmSync(compilerOptions.declarationDir!, { recursive: true });\n        }\n\n        if (shouldDeleteTsConfig && tsconfigPath) {\n            rmSync(tsconfigPath);\n        }\n    } catch (e) {\n        if (shouldDeleteTsConfig && tsconfigPath) {\n            rmSync(tsconfigPath);\n        }\n\n        throw e;\n    }\n}\n","import { LogLevel } from \"esbuild\";\n\nexport function createLogger(logLevel?: LogLevel) {\n    const levels: LogLevel[] = [\n        \"verbose\",\n        \"debug\",\n        \"info\",\n        \"warning\",\n        \"error\",\n        \"silent\",\n    ];\n\n    for (const l of levels) {\n        if (l === logLevel) {\n            break;\n        } else {\n            levels.splice(levels.indexOf(l), 1);\n        }\n    }\n\n    return {\n        info: (...msg: string[]) => {\n            if (levels.includes(\"info\")) console.log(...msg);\n        },\n    };\n}\n"],"mappings":"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","names":["createHash","resolve","ts","getCompilerOptions","opts","_a","_b","_c","_d","compilerOptions","ts","resolve","configHash","createHash","cacheDir","__require","merge","readFileSync","dirname","resolve","ts","resolveModulePath","path","__require","resolveTSConfig","opts","_a","_b","_c","configPath","ts","config","readFileSync","parentConfig","resolve","dirname","merge","humanizeFileSize","size","i","chalk","existsSync","lstatSync","resolve","ts","generateDtsBundle","randomBytes","rmSync","writeFileSync","dirname","pathSeparator","resolve","getHighestCommonDirectory","paths","firstPath","otherPaths","p","commonParts","currentPath","part","i","generateBundle","entryPoints","compilerOptions","tsconfigPath","originalConfig","commonOutDir","relativeDeclarationPaths","entry","postbundleOutDir","shouldDeleteTsConfig","tempid","bundles","path","bundle","originalPath","outputPath","e","createLogger","logLevel","levels","l","msg","dtsPlugin","opts","build","log","createLogger","config","configPath","resolveTSConfig","willBundleDeclarations","compilerOptions","getCompilerOptions","compilerHost","ts","inputFiles","args","_a","errors","m","compilerProgram","diagnostics","d","_","message","warnings","startTime","emitResult","entryPoints","entry","generateBundle","chalk","emittedFile","emittedPath","resolve","existsSync","stat","lstatSync","pathFromContentRoot","humanFileSize","humanizeFileSize"]}